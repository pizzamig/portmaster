#!/bin/sh

# external tools manipulation
: "${PKG:="pkg"}"

# common useful definitions
PM_TRUE=0
PM_FALSE=1

# true if the current shell is the parent shell
pm_is_parent() {
	if [ "$$" -eq "$PM_PARENT_PID" ]; then
		return $PM_TRUE
	else
		return $PM_FALSE
	fi
}

# true if the current shell runs with superuser priviligese
pm_has_su_privileges() {
	if [ $(id -u) -eq 0 ]; then
		return $PM_TRUE
	else
		return $PM_FALSE
	fi
}

# ask the user to type y or n and return properly
# if the user type y or PM_YES, PM_TRUE is returned
# if the user type n or PM_NO, PM_FALSE is returned
# $1 is the default value (affects the output only)
# $2 the message
pm_get_yesno() {
	local default answer
	default=$1 ; shift
	[ -n "${PM_YES}" ] && return $PM_TRUE
	[ -n "${PM_NO}" ] && return $PM_FALSE
	while true ; do
		echo -e "$* [${default}] \c"
		read answer
		echo
		case "$answer" in
		[Nn])
			return $PM_FALSE ;;
		[Yy])
			return $PM_TRUE ;;
		'')
			case "$default" in
			[Nn]) return $PM_FALSE ;;
			[Yy]) return $PM_TRUE ;;
			esac
			;;
		*)
			echo -e "\t===>>> $answer is not a valid answer"
		esac
	done
}

pm_mktemp_file() {
	local _temp
	_temp=$(/usr/bin/mktemp -t pm-${PM_PARENT_PID}-$1 2>&1) ||
		fail "mktemp for $1 failed: \n\t${_temp#mktemp: }"
	echo $_temp
	TEMP_FILE_LIST="${TEMP_FILE_LIST}${_temp} "
}

# removing trailing glob chars
pm_globstrip () {
	local in
	in=${1%[*]}
	in=${in%\\}
	echo $in
}

# Takes a pkg pattern as input( bash, perl, ...) ; return values
# 0 - Matched one and only one package
# 1 - No match
# 2 - Matched multiple packages
# The variabl glob_pkgs will contain the package names
pm_find_glob_pkgs () {
	# Global glob_pkgs
	local pattern num
	pattern="$(pm_globstrip $1)"
	num=$(pkg info -g ${pattern}\* | wc -l | tr -d " ")
	glob_pkgs="$(pkg query -g "%n-%v" ${pattern}\*)"
	case $num in
	0) unset glob_pkgs; return 1 ;;
	1) return 0 ;;
	*) return 2 ;;
	esac
}

# get the origin from a pkg name [name-version]; return values
# 0 - package found
# 1 - package not found
# 2 - package ignored using as +IGNOREME
#     (pdb has to be correctly initialized)
# 3 - bsdpan package (a relics)
pm_get_origin () {
	if [  -e "$pdb/$1/+IGNOREME" ]; then
		echo "  ===>>> $pdb/$1/+IGNOREME exists" >&2
		return 2
	fi
	pkg query '%o' $1 2>/dev/null && return 0
	case "$1" in bsdpan-*) return 3 ;; esac
	return 1
}

# former iport_from_origin | TODO to be adopted | TODO to be tested
# get the installed pkg name [name-version] from an origin; it echos the installed version
# return values
# 0 - package found
# 1 - package not found
# 2 - multiple packages [TODO: check with subpackages and flavor]
pm_get_inst_pkgname () {
	local num rc
	num=$( pkg query -e "%o = ${1}" '%n-%v' | wc -l | tr -d " " )
	case $num in
	0) return 1 ;;
	1) rc=0 ;;
	*) rc=2 ;;
	esac
	pkg query -e "%o = ${1}" '%n-%v'
	return rc
}

# look for moved ports origin
# get the new origin or the reason why it's deleted
# reqs: $pd
# return values
# 0 - origin not found
# 1 - ports moved to another origin
# 2 - ports removed
pm_find_moved_origin () {
	local origin newOrigin reason
	origin=$1
	if [ -n "$(grep "^${origin}||" $pd/MOVED)" ]; then
		# ports removed
		reason=$(grep "^${origin}||" $pd/MOVED | sed "s%^.*||.*|%%")
		echo $reason
		return 2
	fi
	if [ "$(grep -c "^${origin}|" $pd/MOVED)" -eq 1 ]; then
		# ports moved to another origin
		newOrigin=$(grep "^${origin}|" $pd/MOVED | sed "s%^${origin}|%%")
		reason=$(echo $newOrigin | sed "s%.*|.*|%%")
		origin=${newOrigin%%|*}
		newOrigin=$(pm_find_moved_origin $origin)
		case $? in
		0) echo $origin
			return 1 ;;
		1) echo $newOrigin
			return 1 ;;
		2) echo $newOrigin
			return 2 ;;
		esac
	fi
	return 0
}

# get the origin from a pkg name [name-version] with MOVED support
# return values:
# 0 - package found
# 1 - package not found
# 2 - package ignored using as +IGNOREME
#     (pdb has to be correctly initialized)
# 3 - bsdpan package (a relics)
# 4 - origin not valid (not found)
# 5 - origin (pkg) removed
pm_get_moved_origin() {
	local origin
	origin=$(pm_get_origin $1)
	case $? in
	3) return 3 ;;
	2) return 2 ;;
	1) return 1 ;;
	esac
	if [ -d $pd/$origin ]; then
		echo $origin
		return 0;
	fi
	origin=$(pm_find_moved_origin $origin)
	case $? in
	0) return 4 ;;
	2) return 5 ;;
	esac
	echo $origin
	return 0
}

# get the distfiles from a pkg name, using the portstree
# reqs: $pd
pm_get_distfiles () {
	local origin distfiles distsubdir
	origin="$(pm_get_origin $1)"
	if [ ! -d $pd/$origin ]; then
		# check the moved ports
		origin=$(pm_find_moved_origin $origin)
		case $? in
		0|2) return ;;
		esac
	fi
	distsubdir=$(make -C $pd/$origin -V DIST_SUBDIR)
	for df in $(make -C $pd/$origin -V ALLFILES) ; do
		if [ -z "$distsubdir" ]; then
			echo $df
		else
			echo $distsubdir/$df
		fi
	done
}

# get ports lists, per category: roots, trunks, branches, leaves
# exports: roots, trunks, branches, leaves
# exports: num_roots, num_trunks, num_branches, num_leaves, num_ports
pm_ports_by_category () {
	roots=$( pkg query -e "%#d = 0 && %#r = 0" "%n-%v")
	trunks=$( pkg query -e "%#d = 0 && %#r > 0" "%n-%v")
	branches=$( pkg query -e "%#d > 0 && %#r > 0" "%n-%v")
	leaves=$( pkg query -e "%#d > 0 && %#r = 0" "%n-%v")

	num_roots=$( echo $roots | wc -w | tr -d " ")
	num_trunks=$( echo $trunks | wc -w | tr -d " ")
	num_branches=$( echo $branches | wc -w | tr -d " ")
	num_leaves=$( echo $leaves | wc -w | tr -d " ")
	num_ports=$( pkg query -a "%n-%v" | wc -w | tr -d " ")
}

# it checks if the pkg has to be updated (or downgraded)
# $1 the pkgname
# return values:
# 0 - an upgrade (or downgraded) is available
# 1 - no new version available
pm_check_for_updates () {
	local pkgname origin curVersion newVersion
	pkgname=$1
	origin=$(pm_get_moved_origin $1)
	if [ $? -ne 0 ]; then
		return 1
	fi
	curVersion=$( pkg query "%v" $pkgname )
	newVersion=$( make -C $pd/$origin -V PKGVERSION)
	case $(pkg version -t $curVersion $newVersion) in
	\<) # the port version is newer
		echo $newVersion
		;;
	=) return $PM_FALSE ;; # both version are the same (options can differ)
	\>) # the port version is older (downgrade?)
		echo $newVersion
		;;
	esac
	return $PM_TRUE
}

# it creates a backup pkg of the installed pkg
# if NO_BACKUP is set, it retuns true, but no backup is created
# reqs: PACKAGES
# return values:
# 0 - backup pkg created as expected
# 1 - an error occured
pm_backup () {
	local pkgname bkpdir
	pkgname=$1
	[ -n "$NO_BACKUP" ] && return $PM_TRUE
	bkpdir=${PACKAGES}/portmaster-backup

	if [ ! -d $bkpdir ]; then
		mkdir -p $bkpdir
	fi
	[ ! -d $bkpdir ] && return $PM_FALSE
	pkg create --out-dir $bkpdir $pkgname
	return $?
}

#============ High level functions =============

# --clean-distfiles ; no arguments needed
# reqs:    $pd and $DISTDIR
# options: $PM_THOROUGH, $PM_YES, $PM_NO
pm_clean_distfiles () {
	local DI_FILES
	[ -n "$DISTDIR" ] || fail 'DISTDIR is not defined'
	DI_FILES=$(pm_mktemp_file DISTINFO)
	echo "===>>> Gathering distinfo list for installed ports"
	if [ -n "$PM_THOROUGH" ]; then # [ -t ]
		# get the list of distfiles needed by the whole portstree
		for _distinfo in $pd/*/*/distinfo
		do
			fgrep SIZE "$_distinfo" | sed 's/^SIZE (//g' | sed 's/) =.*$//g'
		done > $DI_FILES
	else
		# get the list of distfiles needed by the installed pkgs
		for _pkg in $( pkg query '%n-%v' ) ; do
			pm_get_distfiles $_pkg
		done > $DI_FILES
	fi
	# get the list of distfiles stored in the system and
	# remove distfiles not related to installed pkgs
	echo "===>>> Checking for stale distfiles" ; echo ''
	for _dif in $(find -s $DISTDIR -type f) ; do
		__dif=${_dif#$DISTDIR}
		if ! grep -sql ^$__dif $DI_FILES; then
			pm_get_yesno n "\t===>>> Delete stale file: $__dif"
			case "$?" in
			$PM_TRUE)
				echo -e "\tDeleting $__dif"
				/bin/unlink $__dif ;;
			*)
				continue ;;
			esac
		fi
	done
	# TODO: remove empty directories under /usr/ports/distfiles
	# TODO: clean temporary files and exit
}

# --check-depends ; no arguments needed
# reqs: superuser privileges
pm_check_depends () {
	local origin
	# TODO: pkg check needs superuser privileges Oâ€“O
	pkg check -dnq | while read pkgname missinglib; do
		origin=$(pkg query "%o" $pkgname)
		echo "$pkgname ($origin) requires missing $missinglib"
	done
	# TODO: a clean exit
}

# --check-port-dbdir ; no arguments needed
# reqs: $port_dbdir
# options: $PM_YES, $PM_NO
pm_check_port_dbdir () {
	local dbdir dir
	[ -d "$port_dbdir" ] || fail "PORT_DBDIR is empty or $port_dbdir doesn't exist"

	echo "===>>> Checking $port_dbdir"

	for dir in ${port_dbdir}/*; do
		dbdir=${dir#$port_dbdir/}

		if [ -f $dir ]; then
			continue # files are pkg(8)'s meta and sqlite db
		fi
		# TODO: verbosity message "Checking $dbdir"
		if ! pkg info -e $dbdir ; then
			echo "  ===>>> $dbdir does not seem to be installed"
			if pm_get_yesno n "\t===>>> Delete $dir?" ; then
				pm_rm -rf $dir
			fi
		fi
	done
}

# -l and -L ; LIST_PLUS is -L
pm_list () {
	local newVersion
	pm_ports_by_category
	echo "===>>> Root ports (No dependencies, not depended on)"
	for p in $roots; do
		echo "===>>> $p"
		if [ -n "LIST_PLUS" ]; then
			newVersion=$(pm_check_for_updates $p)
			if [ $? -eq $PM_TRUE ]; then
				echo -e "\tNew version available: $newVersion"
			fi
		fi
	done
	echo "===>>> $num_roots root ports"; echo
	echo "===>>> Trunk ports (No dependencies, are depended on)"
	for p in $trunks; do
		echo "===>>> $p"
		if [ -n "LIST_PLUS" ]; then
			newVersion=$(pm_check_for_updates $p)
			if [ $? -eq $PM_TRUE ]; then
				echo -e "\tNew version available: $newVersion"
			fi
		fi
	done
	echo "===>>> $num_trunks trunk ports"; echo
	echo "===>>> Branches ports (Have dependencies, are depended on)"
	for p in $branches; do
		echo "===>>> $p"
		if [ -n "LIST_PLUS" ]; then
			newVersion=$(pm_check_for_updates $p)
			if [ $? -eq $PM_TRUE ]; then
				echo -e "\tNew version available: $newVersion"
			fi
		fi
	done
	echo "===>>> $num_branches branch ports"; echo
	echo "===>>> Leaf ports (Have dependencies, not depended on)"
	for p in $leaves; do
		echo "===>>> $p"
		if [ -n "LIST_PLUS" ]; then
			newVersion=$(pm_check_for_updates $p)
			if [ $? -eq $PM_TRUE ]; then
				echo -e "\tNew version available: $newVersion"
			fi
		fi
	done
	echo "===>>> $num_leaves leaf ports"; echo
}

# INCOMPLETE AND EXPERIMENTAL
# -e ; the argument has to identify a single package
pm_expunge () {
	local pkgname deplist
	pkgname=$1
	if ! pkg info -e $pkgname ; then
		pm_find_glob_pkgs $pkgname
		case $? in
		1) fail "No match: $pkgname" ;;
		2) echo "Too many matches: $pkgname =>"
			echo "$glob_pkgs"
			fail "The -e option works with only one port at a time" ;;
		0) pkgname=$glob_pkgs
			unset glob_pkgs ;;
		esac
	fi
	deplist=$(pkg query "%rn-%rv" $pkgname)
	if [ -n "$deplist" ]; then
		echo "===>>> Warning: ports dependent on $pkgname"
		echo "$deplist" | tr ' ' '\n'
		pm_get_yesno n "\n\t===>>> Delete those packages as well?"
		if [ $? -eq $PM_FALSE ]; then
			exit 1
		fi
	fi

	if [ -n "$BACKUP" ]; then
		if ! pm_backup $pkgname ;
			pm_get_yesno n "\n\t===>>> Backup failed! Continue?"
			if [ $? -eq $PM_FALSE ]; then
				exit 1
			fi
		fi
	fi
	# delete distfiles won't be performed
	# slaves ports would remove distfiles used by other ports
	# it's a situation not detectable

	echo "===>>> Running pkg delete on $pkgname"
	pkg delete -f -y $pkgname
	for d in $pkgname $deplist ; do
		[ -d $pdb/$d ] && rm -rf $pdb/$d
	done

	# TODO: clean stale!
}

# INCOMPLETE AND EXPERIMENTAL
# -s ; clean stale 
pm_clean_stale () {
	local stale_pkgs
	stale_pkgs=$(pkg query -e '%a = 1 && %?r = 0' '%n-%v')
}

